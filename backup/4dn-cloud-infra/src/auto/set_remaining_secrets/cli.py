# Script for 4dn-cloud-infra to fill out "remaining" secrets in GAC aftere datastore setup.
# Ref: https://hms-dbmi.atlassian.net/wiki/spaces/~627943f598eae500689dbdc7/pages/2844229759/Building+and+Deploying+AWS+Infrastructure#Filling-Out-Remaining-Application-Secrets
# EXPERIMENT IN PROGRESS

# The following values need to be filled in for the global application
# configuration (GAC) secret in AWS:
#
# N.B. For values her which need AWS credentials (aws_access_key_id, aws_secret_access_key),
# we will get these either directly from the command-line, or from the "credentials" file
# and "config" file in either the specified AWS credentials directory, or, by default,
# in the local custom AWS credentials directory, i.e. custom/aws_creds.
#
# N.B. That is, we will NOT rely on the environment of the user invoking this script AT ALL
# for AWS credentials, i.e. neither on the AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and
# AWS_DEFAULT_REGION environment variables, nor on the ~/.aws "credentials" and "config"
# files, nor on the AWS_SHARED_CREDENTIALS_FILE and AWS_CONFIG_FILE environment variables.
# Ref: aws_context.py
#
# - ACCOUNT_NUMBER
#   Get this from "account_number" in custom/config.json, or from
#   boto3.client("sts").get_caller_identity()["Account"] using the
#   specified AWS credentials, and/or both and sanity check each other.
#   Ref: AwsContext.establish_credentials()
#
# - ENCODED_IDENTITY
#   Get this from the identity, i.e. the GAC name,
#   e.g. C4DatastoreCgapSupertestApplicationConfiguration.
#   Ref: Names.application_configuration_secret(aws_credentials_name)
#
# - ENCODED_ES_SERVER
#   Get this from the endpoint property of the AWS ElasticSearch instance definition
#   named es-{aws_credentials_name} where aws_credentials_name is e.g. cgap-supertest.
#   Ref: AwsFunctions.get_opensearch_endpoint()
#   TODO: Since this value is generated by the datastore stack provisioning, which also
#   sets up the GAC, why not use the same code to set this at datastore provisioning time?
#   TODO: Actually it looks like this value IS set during datastore stack provisioning time,
#   to e.g. vpc-es-cgap-supertest-asggiedgb6ilmzjuq4hlwgw2w4.us-east-1.es.amazonaws.com,
#   but without the ":443" port suffix, in application_configuration_template() in
#   datastore.py via call to C4DatastoreExports.get_es_url() in datastore.py.
#   TODO: I have a note in my docs that this cannot actualy be set until ES comes online. Hmm.
#
# - RDS_HOSTNAME, RDS_PASSWORD
#   Get these from the "host" and "password" secret key values in the secret name
#   ending in "RDSSecret" in the AWS Secrets Manager. The "RDSSecret" string is from
#   RDS_SECRET_NAME_SUFFIX in C4Datastore in datastore.py; the "password" string is
#   from rds_secret() in C4Datastore in datastore.py; note sure where "host" is from.
#   TODO: Since RDS_HOSTNAME is generated by the datastore stack provisioning, which also
#   sets up the GAC, why not use the same code to set this at datastore provisioning time?
#   Though cannot yet tell where this is really getting set.
#   Note that the value of the password seems to be generated by AWS via GenerateSecretString.
#
# - ENCODED_S3_ENCRYPT_KEY_ID
#   Get this from the (one single) customer manager key the AWS Key Management Service (KMS).
#   Only set this if "s3.bucket.encryption" is True in custom/config.json.
#   Ref: AwsFunctions.get_customer_managed_kms_keys()
#
# - S3_AWS_ACCESS_KEY_ID, S3_AWS_SECRET_ACCESS_KEY
#   Get these by creating AWS security access key pair for the "federated" IAM user.
#   Get federated IAM user name (e.g. c4-iam-main-stack-C4IAMMainApplicationS3Federator-ZFK91VU2DM1H)
#   from AWS IAM user whose name contains "ApplicationS3Federator" which (that string)
#   is referenced/hardcoded in ecs_s3_iam_user() in iam.py.
#   Ref: AwsFunctions.create_user_access_key()
#
# - S3_ENCRYPT_KEY
#   This gets set automatically it seems.
#   TODO: Though originally this did not seem to be the case.
#   Get (if not already set) from custom/aws_creds/s3_encrypt_key.txt

import argparse
import boto3
import contextlib
import io
import json
import os
import re
from ...names import Names
from ..init_custom_dir.defs import (InfraDirectories, InfraFiles)
from .aws_functions import AwsFunctions
from .utils import (obfuscate, should_obfuscate)


def get_custom_dir(custom_dir: str = None):
    return InfraDirectories.get_custom_dir(custom_dir)


def get_custom_aws_creds_dir(custom_dir: str = None):
    return InfraDirectories.get_custom_aws_creds_dir(custom_dir)


def get_custom_config_file(custom_dir: str = None):
    return InfraFiles.get_config_file(custom_dir)


def get_custom_config_file_value(custom_dir: str, name: str):
    custom_config_file = get_custom_config_file(custom_dir)
    with io.open(custom_config_file, "r") as custom_config_fp:
        custom_config_json = json.load(custom_config_fp)
        return custom_config_json.get(name)
    return None


def get_aws_credentials_name(custom_dir: str = None) -> str:
    return get_custom_config_file_value(custom_dir, "ENCODED_ENV_NAME")


def get_account_number_from_config_file(custom_dir: str = None) -> str:
    return get_custom_config_file_value(custom_dir, "account_number")


def get_s3_bucket_encryption_from_config_file(custom_dir: str = None) -> bool:
    return get_custom_config_file_value(custom_dir, "s3.bucket.encryption")


def get_identity(aws_credentials_name: str) -> str:
    """
    Obtains/returns the 'identity', i.e. the global application configuration name using
    the same code that 4dn-cloud-infra code does (see C4Datastore.application_configuration_secret).
    Had to do some refactoring to get this working (see names.py).

    :param aws_credentials_name: AWS credentials name (e.g. cgap-supertest).
    :return: Identity (global application configuration name) as gotten from the main 4dn-cloud-infra code.
    """
    try:
        identity_value = Names.application_configuration_secret(aws_credentials_name)
    except Exception:
        identity_value = None
    return identity_value


def main():

    args_parser = argparse.ArgumentParser()
    args_parser.add_argument("--custom-dir", type=str, required=False, default=InfraDirectories.CUSTOM_DIR)
    args_parser.add_argument("--access-key", type=str, required=False)
    args_parser.add_argument("--secret-key", type=str, required=False)
    args_parser.add_argument("--region", type=str, required=False)
    args_parser.add_argument("--identity", type=str, required=False)
    args_parser.add_argument("--federated-user", type=str, required=False)
    args_parser.add_argument("--show", action="store_true", required=False)
    args = args_parser.parse_args()

    # Intialize the dictionary secrets to set, which we will collect here.
    secrets_to_update = {}

    # Gather the basic info.
    custom_dir = get_custom_dir(args.custom_dir)
    custom_aws_creds_dir = get_custom_aws_creds_dir(custom_dir)
    custom_config_file = get_custom_config_file(custom_dir)
    aws_credentials_name = get_aws_credentials_name(custom_dir)

    # Get AWS credentials context object.
    aws = AwsFunctions(custom_aws_creds_dir, args.access_key, args.secret_key, args.region)

    # Get the "identity" name, i.e. the global application confguration (GAC) secret name.
    identity = args.identity if args.identity else get_identity(aws_credentials_name)
    secrets_to_update["ENCODED_IDENTITY"] = identity

    print(f"Setting up 4dn-cloud-infra remaining AWS secrets for: {identity}")

    print(f"Your custom directory: {custom_dir}")
    print(f"Your custom config file: {custom_config_file}")
    print(f"Your AWS credentials name: {aws_credentials_name}")
    # TODO: If access key and secrets key specified via command-line should also require region?
    # i.e. so we're not split with some values from command-line and some from AWS credentials/config files?
    if not args.access_key or not args.secret_key:
        custom_aws_creds_dir_symlink_target = os.readlink(custom_aws_creds_dir) if os.path.islink(custom_aws_creds_dir) else None
        if custom_aws_creds_dir_symlink_target:
            print(f"Your AWS credentials directory: {custom_aws_creds_dir}@ ->")
            print(f"                                {custom_aws_creds_dir_symlink_target}")
        else:
            print(f"Your AWS credentials directory: {custom_aws_creds_dir}")
            print(f"Your AWS credentials name: {aws_credentials_name}")

    # Get the AWS ACCOUNT_NUMBER value from the custom/config.json file.
    account_number = get_account_number_from_config_file(custom_dir)
    print(f"Your AWS account number: {account_number}")

    # Verify the AWS credentials context and get the associated ACCOUNT_NUMBER value.
    # If ACCOUNT_NUMBER does not agree with what's in the config file (above) then warning (error?).
    with aws.establish_credentials() as credentials:
        print(f"Your AWS access key: {credentials.access_key_id}")
        print(f"Your AWS access secret: {credentials.secret_access_key if args.show else obfuscate(credentials.secret_access_key)}")
        print(f"Your AWS default region: {credentials.default_region}")
        print(f"Your AWS account number: {credentials.account_number}")
        if account_number != credentials.account_number:
            # TODO: Should this be a hard error?
            print(f"WARNING: Account number from your config file ({account_number}) does not match AWS ({credentials.account_number}).")
        secrets_to_update["ACCOUNT_NUMBER"] = credentials.account_number

    # Get the IAM "federated" user name.
    if args.federated_user:
        federated_user_name = args.federated_user
    else:
        federated_user_name_pattern = "ApplicationS3Federator"
        federated_user_name = aws.find_iam_user_name(federated_user_name_pattern)
    if not federated_user_name:
        # TODO: Should this be a hard error?
        print(f"ERROR: AWS federated user cannot be determined!")
    else:
        print(f"AWS federated user: {federated_user_name}")

    # Get the ElasticSearch host/port.
    es_server = aws.get_opensearch_endpoint(aws_credentials_name)
    print(f"AWS ElasticSearch server: {es_server}")
    secrets_to_update["ENCODED_ES_SERVER"] = es_server

    # Get the RDS hostname and password.
    rds_secret_name = aws.find_secret_name(".*RDSSecret$")
    if not rds_secret_name:
        # TODO: Should this be a hard error?
        print(f"ERROR: Cannot determine RDS secret name!")
    else:
        print(f"RDS secret name: {rds_secret_name}")
        rds_hostname = aws.get_secret_value(rds_secret_name, "host")
        print(f"RDS host name: {rds_hostname}")
        rds_password = aws.get_secret_value(rds_secret_name, "password")
        print(f"RDS host password: {rds_password if args.show else obfuscate(rds_password)}")
        secrets_to_update["RDS_HOST"] = rds_hostname
        secrets_to_update["RDS_PASSWORD"] = rds_password

    # Get the ENCODED_S3_ENCRYPT_KEY_ID from KMS.
    # Only needed if s3.bucket.encryption is True in the local custom config file.
    s3_bucket_encryption = get_s3_bucket_encryption_from_config_file(custom_dir)
    print(f"S3 bucket encryption enabled: {'Yes' if s3_bucket_encryption else 'No'}")
    if not s3_bucket_encryption:
        customer_managed_kms_keys = aws.get_customer_managed_kms_keys()
        if not customer_managed_kms_keys or len(customer_managed_kms_keys) == 0:
            print("Cannot find a customer managed KMS key in AWS.")
        elif customer_managed_kms_keys and len(customer_managed_kms_keys) > 1:
            # TODO: What to do here if more than one exists?
            print("More than one customer managed KMS key found in AWS.")
            for customer_managed_kms_key in sorted(customer_managed_kms_keys, key=lambda key: key):
                print(f"- {customer_managed_kms_key}")
        else:
            s3_encrypt_key_id = customer_managed_kms_keys[0]
            print(f"AWS customer managed KMS (S3 encrypt) key ID: {s3_encrypt_key_id}")
            secrets_to_update["ENCODED_S3_ENCRYPT_KEY_ID"] = s3_encrypt_key_id

    # Create the security access key/secret pait for the IAM "federated" user.
    if federated_user_name:
        key_id, key_secret = aws.create_user_access_key(federated_user_name)
        secrets_to_update["S3_AWS_ACCESS_KEY_ID"] = key_id
        secrets_to_update["S3_AWS_SECRET_ACCESS_KEY"] = key_secret

    # Summarize the secrets which will be set in the GAC.
    print(f"Here are the secrets which will be set for secret: {identity}")
    for secret_key, secret_value in sorted(secrets_to_update.items(), key=lambda item: item[0]):
        if secret_value is None:
            display_secret_value = "<no-value-specified: will be deleted>"
        elif should_obfuscate(secret_key) and not args.show:
            display_secret_value = obfuscate(secret_value)
        else:
            display_secret_value = secret_value
        print(f"- {secret_key}: {display_secret_value}")

    # Confirm that the user wants to got ahead and set these values, and if so, set them.
    yes_or_no = input("Do you want to go ahead and set these secrets in AWS? [yes/no] ").strip().lower()
    if yes_or_no == "yes":
        for secret_key_name, secret_key_value in secrets_to_update.items():
            aws.update_secret_key_value(identity, secret_key_name, secret_key_value, args.show)
        print("Not actually setting now. Testing.")
    else:
        print("No action taken.")


if __name__ == "__main__":
    main()
